---
title: baseMaterialShader
module: 3D
submodule: Material
file: src/webgl/material.js
description: >
  <p>ライト、マテリアル、テクスチャで使用されるデフォルトのシェーダーを取得します。</p>

  <p><a
  href="/reference/p5.Shader/modify/"><code>baseMaterialShader().modify()</code></a>
  を呼び出して、以下のフックのいずれかを変更できます：</p>

  <table>

  <tr><th>フック</th><th>説明</th></tr>

  <tr><td>


  <p><code>void beforeVertex</code></p>

  </td><td>


  <p>頂点シェーダーの開始時に呼び出されます。</p>

  </td></tr>

  <tr><td>


  <p><code>vec3 getLocalPosition</code></p>

  </td><td>


  <p>変換が適用される前に頂点の位置を更新します。<code>vec3 position</code>を受け取り、
  修正されたバージョンを返す必要があります。</p>

  </td></tr>

  <tr><td>


  <p><code>vec3 getWorldPosition</code></p>

  </td><td>


  <p>変換が適用された後に頂点の位置を更新します。<code>vec3 position</code>を受け取り、
  修正されたバージョンを返す必要があります。</p>

  </td></tr>

  <tr><td>


  <p><code>vec3 getLocalNormal</code></p>

  </td><td>


  <p>変換が適用される前に法線を更新します。<code>vec3 normal</code>を受け取り、
  修正されたバージョンを返す必要があります。</p>

  </td></tr>

  <tr><td>


  <p><code>vec3 getWorldNormal</code></p>

  </td><td>


  <p>変換が適用された後に法線を更新します。<code>vec3 normal</code>を受け取り、
  修正されたバージョンを返す必要があります。</p>

  </td></tr>

  <tr><td>


  <p><code>vec2 getUV</code></p>

  </td><td>


  <p>テクスチャ座標を更新します。<code>vec2 uv</code>を受け取り、
  修正されたバージョンを返す必要があります。</p>

  </td></tr>

  <tr><td>


  <p><code>vec4 getVertexColor</code></p>

  </td><td>


  <p>各頂点の色を更新します。<code>vec4 color</code>を受け取り、
  修正されたバージョンを返す必要があります。</p>

  </td></tr>

  <tr><td>


  <p><code>void afterVertex</code></p>

  </td><td>


  <p>頂点シェーダーの終了時に呼び出されます。</p>

  </td></tr>

  <tr><td>


  <p><code>void beforeFragment</code></p>

  </td><td>


  <p>フラグメントシェーダーの開始時に呼び出されます。</p>

  </td></tr>

  <tr><td>


  <p><code>Inputs getPixelInputs</code></p>

  </td><td>


  <p>マテリアルのピクセルごとの入力を更新します。<code>Inputs</code>構造体を受け取ります。
  これには以下が含まれます：</p>

  <ul>

  <li><code>vec3 normal</code>、表面から外向きに指す方向</li>

  <li><code>vec2 texCoord</code>、<code>x</code>と<code>y</code>が0から1の間の値で、
  ピクセルがマッピングされるテクスチャ上の位置をテクスチャサイズの割合として表すベクトル</li>

  <li><code>vec3 ambientLight</code>、頂点の環境光の色</li>

  <li><code>vec4 color</code>、ピクセルの基本マテリアル色</li>

  <li><code>vec3 ambientMaterial</code>、環境光の影響を受けた時のピクセルの色</li>

  <li><code>vec3 specularMaterial</code>、鏡面ハイライトを反射する時のピクセルの色</li>

  <li><code>vec3 emissiveMaterial</code>、ピクセルが発する光の色</li>

  <li><code>float shininess</code>、鏡面反射がどれだけ鋭くなるべきかを表す1から無限大までの数値</li>

  <li><code>float metalness</code>、マテリアルがどれだけ鏡のようであるべきかを表す0から1までの数値

  構造体は修正して返すことができます。</li></ul></td></tr>

  <tr><td>


  <p><code>vec4 combineColors</code></p>

  </td><td>


  <p>光の異なる成分をすべて含む<code>ColorComponents</code>構造体を受け取り、
  それらを1つの最終的な色に結合します。構造体には以下が含まれます：</p>

  <ul>

  <li><code>vec3 baseColor</code>、ピクセルの基本色</li>

  <li><code>float opacity</code>、描画される不透明度（0から1の間）</li>

  <li><code>vec3 ambientColor</code>、環境光の影響を受けた時のピクセルの色</li>

  <li><code>vec3 specularColor</code>、鏡面反射の影響を受けた時のピクセルの色</li>

  <li><code>vec3 diffuse</code>、ピクセルに当たる拡散光の量</li>

  <li><code>vec3 ambient</code>、ピクセルに当たる環境光の量</li>

  <li><code>vec3 specular</code>、ピクセルに当たる鏡面反射の量</li>

  <li><code>vec3 emissive</code>、ピクセルが発する光の量</li>

  </ul>

  </td></tr>

  <tr><td>


  <p><code>vec4 getFinalColor</code></p>

  </td><td>


  <p>混合後の最終的な色を更新します。<code>vec4 color</code>を受け取り、
  修正されたバージョンを返す必要があります。</p>

  </td></tr>

  <tr><td>


  <p><code>void afterFragment</code></p>

  </td><td>


  <p>フラグメントシェーダーの終了時に呼び出されます。</p>

  </td></tr>

  </table>


  <p>ほとんどの場合、フックはGLSL ESバージョン300で記述する必要があります。
  WebGL 2の代わりにWebGL 1を使用している場合は、代わりにGLSL ES 100でフックを記述してください。</p>

  <p><code>baseMaterialShader().inspectHooks()</code>を呼び出すと、
  可能なすべてのフックとそのデフォルトの実装を確認できます。</p>

line: 886
isConstructor: false
itemtype: method
example:
  - |-

    <div modernizr='webgl'>
    <code>
    let myShader;

    function setup() {
      createCanvas(200, 200, WEBGL);
      myShader = baseMaterialShader().modify({
        uniforms: {
          'float time': () => millis()
        },
        'vec3 getWorldPosition': `(vec3 pos) {
          pos.y += 20.0 * sin(time * 0.001 + pos.x * 0.05);
          return pos;
        }`
      });
    }

    function draw() {
      background(255);
      shader(myShader);
      lights();
      noStroke();
      fill('red');
      sphere(50);
    }
    </code>
    </div>
  - |-

    <div modernizr='webgl'>
    <code>
    let myShader;

    function setup() {
      createCanvas(200, 200, WEBGL);
      myShader = baseMaterialShader().modify({
        declarations: 'vec3 myNormal;',
        'Inputs getPixelInputs': `(Inputs inputs) {
          myNormal = inputs.normal;
          return inputs;
        }`,
        'vec4 getFinalColor': `(vec4 color) {
          return mix(
            vec4(1.0, 1.0, 1.0, 1.0),
            color,
            abs(dot(myNormal, vec3(0.0, 0.0, 1.0)))
          );
        }`
      });
    }

    function draw() {
      background(255);
      rotateY(millis() * 0.001);
      shader(myShader);
      lights();
      noStroke();
      fill('red');
      torus(30);
    }
    </code>
    </div>
  - |-

    <div modernizr='webgl'>
    <code>
    let myShader;
    let environment;

    function preload() {
      environment = loadImage('/assets/outdoor_spheremap.jpg');
    }

    function setup() {
      createCanvas(200, 200, WEBGL);
      myShader = baseMaterialShader().modify({
        'Inputs getPixelInputs': `(Inputs inputs) {
          float factor =
            sin(
              inputs.texCoord.x * ${TWO_PI} +
              inputs.texCoord.y * ${TWO_PI}
            ) * 0.4 + 0.5;
          inputs.shininess = mix(1., 100., factor);
          inputs.metalness = factor;
          return inputs;
        }`
      });
    }

    function draw() {
      panorama(environment);
      ambientLight(100);
      imageLight(environment);
      rotateY(millis() * 0.001);
      shader(myShader);
      noStroke();
      fill(255);
      specularMaterial(150);
      sphere(50);
    }
    </code>
    </div>
  - |-

    <div modernizr='webgl'>
    <code>
    let myShader;

    function setup() {
      createCanvas(200, 200, WEBGL);
      myShader = baseMaterialShader().modify({
        'Inputs getPixelInputs': `(Inputs inputs) {
          vec3 newNormal = inputs.normal;
          // シンプルなバンプマッピング：位置に基づいて法線を調整
          newNormal.x += 0.2 * sin(
              sin(
                inputs.texCoord.y * ${TWO_PI} * 10.0 +
                inputs.texCoord.x * ${TWO_PI} * 25.0
              )
            );
          newNormal.y += 0.2 * sin(
            sin(
                inputs.texCoord.x * ${TWO_PI} * 10.0 +
                inputs.texCoord.y * ${TWO_PI} * 25.0
              )
          );
          inputs.normal = normalize(newNormal);
          return inputs;
        }`
      });
    }

    function draw() {
      background(255);
      shader(myShader);
      ambientLight(150);
      pointLight(
        255, 255, 255,
        100*cos(frameCount*0.04), -50, 100*sin(frameCount*0.04)
      );
      noStroke();
      fill('red');
      shininess(200);
      specularMaterial(255);
      sphere(50);
    }
    </code>
    </div>
class: p5
return:
  description: マテリアルシェーダー
  type: p5.Shader
chainable: false
beta: true
---


# baseMaterialShader