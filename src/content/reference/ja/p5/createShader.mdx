---
title: createShader
module: 3D
submodule: Material
file: src/webgl/material.js
description: >
  <p>Creates a new <a href="/reference/p5/p5.Shader">p5.Shader</a> object.</p>

  <p>Shaders are programs that run on the graphics processing unit (GPU). They

  can process many pixels at the same time, making them fast for many

  graphics tasks. They’re written in a language called

  <a
  href="https://developer.mozilla.org/en-US/docs/Games/Techniques/3D_on_the_web/GLSL_Shaders"
  target="_blank">GLSL</a>

  and run along with the rest of the code in a sketch.</p>

  <p>Once the <a href="/reference/p5/p5.Shader">p5.Shader</a> object is created,
  it can be

  used with the <a href="/reference/p5/shader">shader()</a> function, as in

  <code>shader(myShader)</code>. A shader program consists of two parts, a
  vertex shader

  and a fragment shader. The vertex shader affects where 3D geometry is drawn

  on the screen and the fragment shader affects color.</p>

  <p>The first parameter, <code>vertSrc</code>, sets the vertex shader. It’s a
  string that

  contains the vertex shader program written in GLSL.</p>

  <p>The second parameter, <code>fragSrc</code>, sets the fragment shader. It’s
  a string

  that contains the fragment shader program written in GLSL.</p>

  <p>Note: Only filter shaders can be used in 2D mode. All shaders can be used

  in WebGL mode.</p>
line: 173
isConstructor: false
itemtype: method
example:
  - |-

    <div modernizr='webgl'>
    <code>
    // Note: A "uniform" is a global variable within a shader program.

    // Create a string with the vertex shader program.
    // The vertex shader is called for each vertex.
    let vertSrc = `
    precision highp float;
    uniform mat4 uModelViewMatrix;
    uniform mat4 uProjectionMatrix;
    attribute vec3 aPosition;
    attribute vec2 aTexCoord;
    varying vec2 vTexCoord;

    void main() {
      vTexCoord = aTexCoord;
      vec4 positionVec4 = vec4(aPosition, 1.0);
      gl_Position = uProjectionMatrix * uModelViewMatrix * positionVec4;
    }
    `;

    // Create a string with the fragment shader program.
    // The fragment shader is called for each pixel.
    let fragSrc = `
    precision highp float;

    void main() {
      // Set each pixel's RGBA value to yellow.
      gl_FragColor = vec4(1.0, 1.0, 0.0, 1.0);
    }
    `;

    function setup() {
      createCanvas(100, 100, WEBGL);

      // Create a p5.Shader object.
      let shaderProgram = createShader(vertSrc, fragSrc);

      // Compile and apply the p5.Shader object.
      shader(shaderProgram);

      // Style the drawing surface.
      noStroke();

      // Add a plane as a drawing surface.
      plane(100, 100);

      describe('A yellow square.');
    }
    </code>
    </div>

    <div>
    <code>
    // Note: A "uniform" is a global variable within a shader program.

    // Create a string with the vertex shader program.
    // The vertex shader is called for each vertex.
    let vertSrc = `
    precision highp float;
    uniform mat4 uModelViewMatrix;
    uniform mat4 uProjectionMatrix;
    attribute vec3 aPosition;
    attribute vec2 aTexCoord;
    varying vec2 vTexCoord;

    void main() {
      vTexCoord = aTexCoord;
      vec4 positionVec4 = vec4(aPosition, 1.0);
      gl_Position = uProjectionMatrix * uModelViewMatrix * positionVec4;
    }
    `;

    // Create a string with the fragment shader program.
    // The fragment shader is called for each pixel.
    let fragSrc = `
    precision highp float;
    uniform vec2 p;
    uniform float r;
    const int numIterations = 500;
    varying vec2 vTexCoord;

    void main() {
      vec2 c = p + gl_FragCoord.xy * r;
      vec2 z = c;
      float n = 0.0;

      for (int i = numIterations; i > 0; i--) {
        if (z.x * z.x + z.y * z.y > 4.0) {
          n = float(i) / float(numIterations);
          break;
        }
        z = vec2(z.x * z.x - z.y * z.y, 2.0 * z.x * z.y) + c;
      }

      gl_FragColor = vec4(
        0.5 - cos(n * 17.0) / 2.0,
        0.5 - cos(n * 13.0) / 2.0,
        0.5 - cos(n * 23.0) / 2.0,
        1.0
      );
    }
    `;

    function setup() {
      createCanvas(100, 100, WEBGL);

      // Create a p5.Shader object.
      let mandelbrot = createShader(vertSrc, fragSrc);

      // Compile and apply the p5.Shader object.
      shader(mandelbrot);

      // Set the shader uniform p to an array.
      // p is the center point of the Mandelbrot image.
      mandelbrot.setUniform('p', [-0.74364388703, 0.13182590421]);

      // Set the shader uniform r to 0.005.
      // r is the size of the image in Mandelbrot-space.
      mandelbrot.setUniform('r', 0.005);

      // Style the drawing surface.
      noStroke();

      // Add a plane as a drawing surface.
      plane(100, 100);

      describe('A black fractal image on a magenta background.');
    }
    </code>
    </div>

    <div>
    <code>
    // Note: A "uniform" is a global variable within a shader program.

    // Create a string with the vertex shader program.
    // The vertex shader is called for each vertex.
    let vertSrc = `
    precision highp float;
    uniform mat4 uModelViewMatrix;
    uniform mat4 uProjectionMatrix;

    attribute vec3 aPosition;
    attribute vec2 aTexCoord;
    varying vec2 vTexCoord;

    void main() {
      vTexCoord = aTexCoord;
      vec4 positionVec4 = vec4(aPosition, 1.0);
      gl_Position = uProjectionMatrix * uModelViewMatrix * positionVec4;
    }
    `;

    // Create a string with the fragment shader program.
    // The fragment shader is called for each pixel.
    let fragSrc = `
    precision highp float;
    uniform vec2 p;
    uniform float r;
    const int numIterations = 500;
    varying vec2 vTexCoord;

    void main() {
      vec2 c = p + gl_FragCoord.xy * r;
      vec2 z = c;
      float n = 0.0;

      for (int i = numIterations; i > 0; i--) {
        if (z.x * z.x + z.y * z.y > 4.0) {
          n = float(i) / float(numIterations);
          break;
        }

        z = vec2(z.x * z.x - z.y * z.y, 2.0 * z.x * z.y) + c;
      }

      gl_FragColor = vec4(
        0.5 - cos(n * 17.0) / 2.0,
        0.5 - cos(n * 13.0) / 2.0,
        0.5 - cos(n * 23.0) / 2.0,
        1.0
      );
    }
    `;

    let mandelbrot;

    function setup() {
      createCanvas(100, 100, WEBGL);

      // Create a p5.Shader object.
      mandelbrot = createShader(vertSrc, fragSrc);

      // Apply the p5.Shader object.
      shader(mandelbrot);

      // Set the shader uniform p to an array.
      // p is the center point of the Mandelbrot image.
      mandelbrot.setUniform('p', [-0.74364388703, 0.13182590421]);

      describe('A fractal image zooms in and out of focus.');
    }

    function draw() {
      // Set the shader uniform r to a value that oscillates
      // between 0 and 0.005.
      // r is the size of the image in Mandelbrot-space.
      let radius = 0.005 * (sin(frameCount * 0.01) + 1);
      mandelbrot.setUniform('r', radius);

      // Style the drawing surface.
      noStroke();

      // Add a plane as a drawing surface.
      plane(100, 100);
    }
    </code>
    </div>
class: p5
params:
  - name: vertSrc
    description: |
      <p>source code for the vertex shader.</p>
    type: String
  - name: fragSrc
    description: |
      <p>source code for the fragment shader.</p>
    type: String
return:
  description: |-
    new shader object created from the
    vertex and fragment shaders.
  type: p5.Shader
chainable: false
---


# createShader
